
input : {
    data : {
	control : {
	    reosource : {
		width : 128,
		depth : 16
	    }
	    field : {
		source_addr:32,
		dest_addr:32,
		source_port:16,
		dest_port:16,
		num_of_bytes:32
	    }
	}
	data : {
	    resource : {
		width : 32,
		depth : 2048
	    }
	}
    }
}

output : {
    type : UPL,
    data : {
	packet : {
	    resource : {
		width : 32
	    }
	    field : {
		data 
	    }
	}
    }
}

registers : [
    send_words : { width : 32 }
]
variables : [
    send_words_var : { width : 32 }
]

@IDLE {
    $output.UPL.request <= '0';
}

@RECV($input.valid){
    if $output.ready = '1' then
        $output.UPL.request <= '0';
        $output.UPL.enable <= '0';
        $output.data.packet.data <= $input.data.control.field.source_addr;
	%send_words_var := \"00\" & $input.data.control.field.num_of_bytes(31 downto 2);
	if $input.data.control.field.num_of_bytes(1 downto 0) > 0 then
	  %send_words_var := %send_words_var + 1;
	end if;
        %send_words <= %send_words_var;
        @TO RECV1
    else
        $output.UPL.request <= '1';
    end if;
}

@RECV1{
    $output.data.packet.data <= $input.data.control.field.dest_addr;

}

    stage :
    ["
    "],
    ["
    "],
    ["
	$output.data.packet.data <= $input.data.control.field.dest_port & $input.data.control.field.source_port;
    "],
    ["
	$output.data.packet.data <= $input.data.control.field.num_of_bytes;
    "],
    ["
        if %send_words = 0 then
           goto @receive.done
            else
              send_words <= send_words - 1;
              if send_words >= 2 then -- for next
                data_rd <= '1';
              else
                data_rd <= '0';
              end if;
              UPL_EN   <= '1';
              UPL_DOUT <= data_dout;
            end if;
	if(receive.counter-4 = send_words+1)
	output.data.packet.data <= input.data.control.field.source_addr;
    "],
}
        case to_integer(state_counter) is
          when 0 =>
            if ctrl_valid = '1' then
              ctrl_rd  <= '1';
              ctrl_reg <= ctrl_din;
              UPL_REQ  <= '1';
              tmp      := unsigned(ctrl_din(31 downto 0));
              if tmp > 0 then
                state_counter <= state_counter + 1;
                tmp           := "00" & tmp(31 downto 2);
                --if tmp(1 downto 0) > 0 then
                --  tmp := tmp + 1;
                --end if;
                send_words <= tmp;
              end if;
            else
              UPL_REQ <= '0';
              ctrl_rd <= '0';
            end if;
            data_rd <= '0';
          when 1 =>
            ctrl_rd <= '0';
            data_rd <= '0';
            if UPL_ACK = '1' then
              UPL_REQ       <= '0';
              UPL_DOUT      <= ctrl_reg(127 downto 96);
              UPL_EN        <= '1';
              state_counter <= state_counter + 1;
            else
              UPL_REQ <= '1';
            end if;
          when 2 =>
            UPL_EN        <= '1';
            UPL_DOUT      <= ctrl_reg(95 downto 64);
            state_counter <= state_counter + 1;
            data_rd       <= '0';
          when 3 =>
            UPL_EN        <= '1';
            UPL_DOUT      <= ctrl_reg(63 downto 32);
            state_counter <= state_counter + 1;
            data_rd       <= '1'; -- for next next
          when 4 =>
            UPL_EN        <= '1';
            UPL_DOUT      <= ctrl_reg(31 downto 0);
            state_counter <= state_counter + 1;
            if send_words >= 2 then -- for next
              data_rd       <= '1';
            else
              data_rd       <= '0';
            end if;
          when 5 =>
          when others =>
            null;
        end case;
        
      end if;
    end if;
  end process;
  
end RTL;
